import sqlite3
from sqlite3 import Connection

import aiosqlite
from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, InlineQueryResultArticle, \
    InputTextMessageContent, KeyboardButton
import asyncio
import logging
import sys

from token_of_bot import API_TOKEN

TOKEN = API_TOKEN
DB_FILE = 'database.db'

# Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€Ð¾Ð²
bot = Bot(token=TOKEN)
dp = Dispatcher()

# ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ° Ð»Ð¾Ð³Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ
logging.basicConfig(level=logging.INFO, stream=sys.stdout)

# Ð¡Ð¿Ð¸ÑÐ¾Ðº ÐºÐ¾Ð¼Ð°Ð½Ð´
COMMANDS = [
    "/start",
    "/help",
    "Ð˜Ð·ÑƒÑ‡ÐµÐ½Ð¸Ðµ ÑÐ»Ð¾Ð²",
    "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ñ‚ÐµÐ¼Ñƒ",
    "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ ÑÐ»Ð¾Ð²Ð°",
    "Ð’Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Ñ‚ÐµÐ¼Ñƒ"
]

# Ð¡Ð¾ÑÑ‚Ð¾ÑÐ½Ð¸Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
class Form(StatesGroup):
    waiting_for_topic_name = State()
    waiting_for_word = State()
    waiting_for_translation = State()

@dp.message(F.text == "ÐžÑ‚Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ")
async def cancel_action(message: types.Message, state: FSMContext) -> None:
    await state.clear()  # Ð¡Ð±Ñ€Ð°ÑÑ‹Ð²Ð°ÐµÐ¼ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ
    # kb = ReplyKeyboardMarkup(resize_keyboard=True)
    kb = [
        [(types.KeyboardButton(text="Ð˜Ð·ÑƒÑ‡ÐµÐ½Ð¸Ðµ ÑÐ»Ð¾Ð²"))],
        [(types.KeyboardButton(text="ÐŸÑ€Ð¾Ñ„Ð¸Ð»ÑŒ"))]
        ]
    keyboard = ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)
    await message.answer("Ð’Ñ‹ Ð¾Ñ‚Ð¼ÐµÐ½Ð¸Ð»Ð¸ Ñ‚ÐµÐºÑƒÑ‰ÐµÐµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ. Ð§Ñ‚Ð¾ Ð²Ñ‹ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ ÑÐ´ÐµÐ»Ð°Ñ‚ÑŒ Ð´Ð°Ð»ÑŒÑˆÐµ?", reply_markup=keyboard)

# Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ Ð½Ð° Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´
def is_command(text: str) -> bool:
    return text.startswith('/')

# Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ñ Ñ Ð±Ð°Ð·Ð¾Ð¹ Ð´Ð°Ð½Ð½Ñ‹Ñ…
def create_connection(db_file: str) -> Connection:
    try:
        conn = sqlite3.connect(db_file)
        logging.info("Connection to database established.")
        return conn
    except sqlite3.Error as e:
        logging.error(f"Database connection error: {e}")
        raise

# Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ð¸Ð»Ð¸ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Ð±Ð°Ð·Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ…
def upsert_user(user_id: int, username_tg: str, full_name: str, balance: int = 0, elite_status: str = 'No',
                learned_words_count: int = 0) -> None:
    conn = create_connection(DB_FILE)
    try:
        cursor = conn.cursor()
        cursor.execute("""INSERT INTO users (user_id, username_tg, full_name, balance, elite_status, learned_words_count)
                          VALUES (?, ?, ?, ?, ?, ?)
                          ON CONFLICT(user_id) DO UPDATE SET
                              username_tg = excluded.username_tg,
                              full_name = excluded.full_name,
                              balance = excluded.balance,
                              elite_status = excluded.elite_status,
                              learned_words_count = excluded.learned_words_count
                       """, (user_id, username_tg, full_name, balance, elite_status, learned_words_count))
        conn.commit()
    except sqlite3.Error as e:
        logging.error(f"Database error: {e}")
    finally:
        conn.close()

# Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ñ‚ÐµÐ¼Ñ‹ Ð² Ð±Ð°Ð·Ñƒ Ð´Ð°Ð½Ð½Ñ‹Ñ… (Ñ Ð¿Ñ€Ð¸Ð²ÑÐ·ÐºÐ¾Ð¹ Ðº Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŽ)
def add_user_topic(author_id: int, content: str, visible: int) -> None:
    conn = create_connection(DB_FILE)
    try:
        cursor = conn.cursor()
        cursor.execute("""INSERT INTO topics (author_id, content, visible)
                          VALUES (?, ?, ?)
                          ON CONFLICT(id) DO NOTHING
                       """, (author_id, content, visible))
        conn.commit()
    except sqlite3.Error as e:
        logging.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð±Ð°Ð·Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¿Ñ€Ð¸ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ð¸ Ñ‚ÐµÐ¼Ñ‹: {e}")
    finally:
        conn.close()

# Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ ÑÐ»Ð¾Ð²Ð° Ð² Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½ÑƒÑŽ Ñ‚ÐµÐ¼Ñƒ
async def add_word_to_user_topic(user_id: int, topic_id: int, word: str, translation: str, state: FSMContext) -> None:
    conn = create_connection(DB_FILE)
    try:
        cursor = conn.cursor()
        cursor.execute("""INSERT INTO user_dictionary (user_id, topic_id, word, translation)
                          VALUES (?, ?, ?, ?)
                       """, (user_id, topic_id, word, translation))
        update_learned_words_count(user_id)
        conn.commit()
        await state.clear()
    except sqlite3.Error as e:
        logging.error(f"Database error: {e}")
    finally:
        conn.close()

# Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð° Ð¸Ð·ÑƒÑ‡ÐµÐ½Ð½Ñ‹Ñ… ÑÐ»Ð¾Ð²
def update_learned_words_count(user_id: int) -> None:
    conn = create_connection(DB_FILE)
    try:
        cursor = conn.cursor()
        cursor.execute("""SELECT COUNT(*) FROM user_dictionary WHERE user_id = ?""", (user_id,))
        learned_words_count = cursor.fetchone()[0]
        cursor.execute("""UPDATE users SET learned_words_count = ? WHERE user_id = ?""", (learned_words_count, user_id))
        conn.commit()
        return learned_words_count
    except sqlite3.Error as e:
        logging.error(f"Database error: {e}")
        return 0
    finally:
        conn.close()

# Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ Ð¿Ð¾Ð¸ÑÐºÐ° Ñ‚ÐµÐ¼ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
def search_user_topics(user_id: int, query: str) -> list:
    conn = create_connection(DB_FILE)
    try:
        cursor = conn.cursor()
        cursor.execute("""SELECT id, content 
                          FROM topics 
                          WHERE (author_id = ? OR visible = 1) 
                          AND content LIKE ?""", (user_id, f"%{query}%"))
        return cursor.fetchall()
    except sqlite3.Error as e:
        logging.error(f"Database error: {e}")
        return []
    finally:
        conn.close()


# ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð½Ð°Ð¶Ð°Ñ‚Ð¸Ñ Ð½Ð° ÐºÐ½Ð¾Ð¿ÐºÑƒ "ÐÐ°Ñ‡Ð°Ñ‚ÑŒ Ð¾Ð±ÑƒÑ‡ÐµÐ½Ð¸Ðµ!"
@dp.callback_query(lambda c: c.data == 'start_learning')
async def process_start_learning(callback_query: types.CallbackQuery) -> None:
    user_id = callback_query.from_user.id
    await bot.answer_callback_query(callback_query.id)

    kb = [
        [types.KeyboardButton(text="Ð˜Ð·ÑƒÑ‡ÐµÐ½Ð¸Ðµ ÑÐ»Ð¾Ð²")],
        [types.KeyboardButton(text="ÐŸÑ€Ð¾Ñ„Ð¸Ð»ÑŒ")]
    ]
    keyboard = ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

    await bot.send_message(user_id, "Ð’Ñ‹ Ð½Ð°Ñ‡Ð°Ð»Ð¸ Ð¸Ð·ÑƒÑ‡ÐµÐ½Ð¸Ðµ! Ð§Ñ‚Ð¾ Ð²Ñ‹ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ ÑÐ´ÐµÐ»Ð°Ñ‚ÑŒ?", reply_markup=keyboard)

# ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð²Ð½ÑƒÑ‚Ñ€ÐµÐ½Ð½Ð¾ÑÑ‚ÐµÐ¹ "Ð˜Ð·ÑƒÑ‡ÐµÐ½Ð¸Ðµ ÑÐ»Ð¾Ð²"
@dp.message(F.text == "Ð˜Ð·ÑƒÑ‡ÐµÐ½Ð¸Ðµ ÑÐ»Ð¾Ð²")
async def learning(message: types.Message) -> None:
    user_id = message.from_user.id

    kb = [
        [types.KeyboardButton(text="Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ñ‚ÐµÐ¼Ñƒ")],
        [types.KeyboardButton(text="Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ ÑÐ»Ð¾Ð²Ð°")]
    ]
    keyboard = ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

    await message.answer("Ð§Ñ‚Ð¾ Ð²Ñ‹ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ ÑÐ´ÐµÐ»Ð°Ñ‚ÑŒ Ð´Ð°Ð»ÑŒÑˆÐµ?", reply_markup=keyboard)

# ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð½Ð°Ð¶Ð°Ñ‚Ð¸Ñ Ð½Ð° ÐºÐ½Ð¾Ð¿ÐºÑƒ "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ñ‚ÐµÐ¼Ñƒ"
@dp.message(F.text == "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ñ‚ÐµÐ¼Ñƒ")
async def add_topic_prompt(message: types.Message, state: FSMContext) -> None:
    await state.clear()  # Ð¡Ð±Ñ€Ð°ÑÑ‹Ð²Ð°ÐµÐ¼ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ Ð¿ÐµÑ€ÐµÐ´ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ¾Ð¹ Ð½Ð¾Ð²Ð¾Ð³Ð¾
    kb = [
        [(KeyboardButton(text="ÐžÑ‚Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ"))],
    ]
    keyboard = ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)
    await message.answer("Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ñ‚ÐµÐ¼Ñ‹:", reply_markup=keyboard)
    await state.set_state(Form.waiting_for_topic_name.state)


# ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ñ‚ÐµÐºÑÑ‚Ð° Ð´Ð»Ñ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ñ‚ÐµÐ¼Ñ‹
@dp.message(Form.waiting_for_topic_name)
async def process_add_topic(message: types.Message, state: FSMContext) -> None:
    author_id = message.from_user.id
    content = message.text

    if is_command(message.text):
        await message.answer("Ð’Ñ‹ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ Ð² ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ðµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ð¹ Ñ‚ÐµÐ¼.")
        return

    if content:
        add_user_topic(author_id, content, 0)
        await message.answer("Ð’Ñ‹ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð´Ð¾Ð±Ð°Ð²Ð¸Ð»Ð¸ Ñ‚ÐµÐ¼Ñƒ! Ð§Ñ‚Ð¾ Ð²Ñ‹ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ ÑÐ´ÐµÐ»Ð°Ñ‚ÑŒ Ð´Ð°Ð»ÑŒÑˆÐµ?")
        await state.clear()
        logging.info(f"Ð¢ÐµÐ¼Ð° '{content}' Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð° Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¼ {author_id}. Ð¡Ð¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ ÑÐ±Ñ€Ð¾ÑˆÐµÐ½Ð¾.")
    else:
        await message.answer("ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ñ‚ÐµÐ¼Ñ‹ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð¿ÑƒÑÑ‚Ñ‹Ð¼.")
        logging.warning(f"ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ {author_id} Ð²Ð²ÐµÐ» Ð¿ÑƒÑÑ‚Ð¾Ðµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ñ‚ÐµÐ¼Ñ‹.")

# ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ ÑÐ»Ð¾Ð²Ð°"
@dp.message(F.text == "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ ÑÐ»Ð¾Ð²Ð°")
async def add_words_prompt(message: types.Message, state: FSMContext) -> None:
    await state.clear()  # Ð¡Ð±Ñ€Ð°ÑÑ‹Ð²Ð°ÐµÐ¼ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Ð’Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Ñ‚ÐµÐ¼Ñƒ", switch_inline_query_current_chat="")]
    ])
    await message.answer("Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ñ‚ÐµÐ¼Ñƒ Ð¸Ð· Ð¿Ñ€ÐµÐ´Ð»Ð¾Ð¶ÐµÐ½Ð½Ñ‹Ñ…:", reply_markup=kb)

@dp.inline_query()
async def inline_query_handler(inline_query: types.InlineQuery) -> None:
    query = inline_query.query.strip()
    user_id = inline_query.from_user.id

    # ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ðº Ð±Ð°Ð·Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ…
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    try:
        # ÐŸÐ¾Ð¸ÑÐº Ñ‚ÐµÐ¼ Ð¿Ð¾ Ð·Ð°Ð¿Ñ€Ð¾ÑÑƒ, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑ ÑÑ‚Ð¾Ð»Ð±ÐµÑ† `content`
        cursor.execute("""SELECT id, content
                          FROM topics
                          WHERE (author_id = ? OR visible = 1) AND content LIKE ? 
                       """, (user_id, f'%{query}%'))
        results = cursor.fetchall()
    except sqlite3.OperationalError as e:
        logging.error(f"Database error: {e}")
        results = []
    finally:
        conn.close()

    # Ð¤Ð¾Ñ€Ð¼Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð²
    items = [
        InlineQueryResultArticle(
            id=str(item[0]),
            title=item[1],
            input_message_content=InputTextMessageContent(message_text=f"Ð’Ñ‹ Ð²Ñ‹Ð±Ñ€Ð°Ð»Ð¸ Ñ‚ÐµÐ¼Ñƒ: {item[1]}")
        )
        for item in results
    ]
    if not items:
        items = [
            InlineQueryResultArticle(
                id="no_results",
                title="ÐÐµÑ‚ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ñ… Ñ‚ÐµÐ¼",
                input_message_content=InputTextMessageContent(message_text="ÐÐµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾ Ñ‚ÐµÐ¼ Ð¿Ð¾ Ð²Ð°ÑˆÐµÐ¼Ñƒ Ð·Ð°Ð¿Ñ€Ð¾ÑÑƒ.")
            )
        ]
    # ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ° Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð²
    await bot.answer_inline_query(inline_query.id, results=items)



# ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð½Ð°Ð¶Ð°Ñ‚Ð¸Ñ Ð½Ð° ÐºÐ½Ð¾Ð¿ÐºÑƒ "Ð’Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Ñ‚ÐµÐ¼Ñƒ"
@dp.message(F.text == "Ð’Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Ñ‚ÐµÐ¼Ñƒ")
async def choose_topic(message: types.Message, state: FSMContext) -> None:
    user_id = message.from_user.id
    topics = search_user_topics(user_id, '')  # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð²ÑÐµ Ñ‚ÐµÐ¼Ñ‹ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ

    logging.info(f"Found topics for user {user_id}: {topics}")

    if topics:
        kb = [[types.InlineKeyboardButton(text=content, callback_data=f"select_topic_{id_}") for id_, content in topics]]
        keyboard = InlineKeyboardMarkup(inline_keyboard=kb)
        await message.answer("Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ñ‚ÐµÐ¼Ñƒ Ð¸Ð· Ð¿Ñ€ÐµÐ´Ð»Ð¾Ð¶ÐµÐ½Ð½Ñ‹Ñ…:", reply_markup=keyboard)
    else:
        await message.answer("Ð£ Ð²Ð°Ñ Ð½ÐµÑ‚ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ñ… Ñ‚ÐµÐ¼. ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, ÑÐ¾Ð·Ð´Ð°Ð¹Ñ‚Ðµ Ñ…Ð¾Ñ‚Ñ Ð±Ñ‹ Ð¾Ð´Ð½Ñƒ Ñ‚ÐµÐ¼Ñƒ.")

# ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð²Ñ‹Ð±Ð¾Ñ€Ð° Ñ‚ÐµÐ¼Ñ‹ Ð¸Ð· inline ÐºÐ»Ð°Ð²Ð¸Ð°Ñ‚ÑƒÑ€Ñ‹
@dp.callback_query(lambda c: c.data.startswith('select_topic_'))
async def process_topic_selection_callback(callback_query: types.CallbackQuery, state: FSMContext) -> None:
    topic_id = callback_query.data.split("_")[-1]
    await bot.answer_callback_query(callback_query.id)

    logging.info(f"Callback received: {callback_query.data}")
    logging.info(f"Selected topic ID: {topic_id}")

    conn = create_connection(DB_FILE)
    cursor = conn.cursor()

    try:
        cursor.execute("SELECT content FROM topics WHERE id = ?", (topic_id,))
        topic_content = cursor.fetchone()
        logging.info(f"Fetched topic content: {topic_content}")

        cursor.execute("SELECT COUNT(*) FROM user_dictionary WHERE topic_id = ?", (topic_id,))
        word_count = cursor.fetchone()[0]
        logging.info(f"Word count for topic ID {topic_id}: {word_count}")

        if topic_content:
            topic_name = topic_content[0]
            message_text = f"*{topic_name}*\nÐšÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ ÑÐ»Ð¾Ð²: {word_count}"

            await bot.send_message(callback_query.from_user.id, message_text, parse_mode='Markdown')

            kb = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ ÑÐ»Ð¾Ð²Ð°", callback_data=f"add_words:{topic_id}"),
                 InlineKeyboardButton(text="Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ñ‚ÐµÐ¼Ñƒ", callback_data=f"delete_topic:{topic_id}")]
            ])
            await bot.send_message(callback_query.from_user.id, "Ð§Ñ‚Ð¾ Ð²Ñ‹ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ ÑÐ´ÐµÐ»Ð°Ñ‚ÑŒ Ð´Ð°Ð»ÑŒÑˆÐµ?", reply_markup=kb)
        else:
            await bot.send_message(callback_query.from_user.id, "Ð¢ÐµÐ¼Ð° Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð°.")
    except sqlite3.Error as e:
        logging.error(f"Database error: {e}")
        await bot.send_message(callback_query.from_user.id, "ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ð¸ Ð´Ð°Ð½Ð½Ñ‹Ñ….")
    finally:
        conn.close()


# ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ñ‚ÐµÐºÑÑ‚Ð° Ð´Ð»Ñ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ ÑÐ»Ð¾Ð²Ð°
@dp.message(F.state == Form.waiting_for_word | F.state == Form.waiting_for_translation)
async def handle_word_translation(message: types.Message, state: FSMContext) -> None:
    current_state = await state.get_state()
    word = message.text

    # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, ÐµÑÐ»Ð¸ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ ÑÐ²Ð»ÑÐµÑ‚ÑÑ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¾Ð¹
    if is_command(message.text):
        await message.answer("Ð’Ñ‹ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´ Ð² ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ðµ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð².")
        return

    # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ Ð²Ð²ÐµÐ´ÐµÐ½Ð½Ð¾Ð³Ð¾ ÑÐ»Ð¾Ð²Ð° Ð¸ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ðµ Ð¿ÐµÑ€ÐµÐ²Ð¾Ð´Ð°
    await state.update_data(word_to_add=word)
    await message.answer("Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¿ÐµÑ€ÐµÐ²Ð¾Ð´ ÑÐ»Ð¾Ð²Ð°:")
    await state.set_state(Form.waiting_for_translation.state)

# ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ñ‚ÐµÐºÑÑ‚Ð° Ð´Ð»Ñ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ð¿ÐµÑ€ÐµÐ²Ð¾Ð´Ð°
@dp.message(F.state.in_(Form.waiting_for_translation))
async def process_translation(message: types.Message, state: FSMContext) -> None:
    user_id = message.from_user.id
    translation = message.text
    data = await state.get_data()
    word = data.get('word_to_add')
    topic_id = data.get('selected_topic_id')

    if not topic_id:
        await message.answer("ÐžÑˆÐ¸Ð±ÐºÐ°: Ð½Ðµ Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð° Ñ‚ÐµÐ¼Ð° Ð´Ð»Ñ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ ÑÐ»Ð¾Ð²Ð°.")
        return

    if is_command(translation):
        await message.answer("Ð’Ñ‹ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´ Ð² ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ðµ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð².")
        return

    await add_word_to_user_topic(user_id, topic_id, word, translation, state)
    await state.clear()

    kb = [
        [types.KeyboardButton(text="Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ñ‚ÐµÐ¼Ñƒ")],
        [types.KeyboardButton(text="Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ ÑÐ»Ð¾Ð²Ð°")]
    ]
    keyboard = ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

    await message.answer(f"Ð’Ñ‹ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð´Ð¾Ð±Ð°Ð²Ð¸Ð»Ð¸ ÑÐ»Ð¾Ð²Ð¾ '{word}' Ð² Ñ‚ÐµÐ¼Ñƒ Ñ ID '{topic_id}'!", reply_markup=keyboard)

########################################################################################################################

# ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ /help
@dp.message(Command("help"))
async def cmd_help(message: types.Message) -> None:
    await message.answer("Ð­Ñ‚Ð¾ Ð±Ð¾Ñ‚ Ð´Ð»Ñ Ð¸Ð·ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð°Ð½Ð³Ð»Ð¸Ð¹ÑÐºÐ¾Ð³Ð¾ ÑÐ·Ñ‹ÐºÐ°. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ Ð¸ ÐºÐ½Ð¾Ð¿ÐºÐ¸ Ð´Ð»Ñ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ñ‚ÐµÐ¼ Ð¸ ÑÐ»Ð¾Ð².")

########################################################################################################################

# ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ /start
@dp.message(Command("start"))
async def cmd_start(message: types.Message, state: FSMContext) -> None:
    await state.clear()  # Ð¡Ð±Ñ€Ð°ÑÑ‹Ð²Ð°ÐµÐ¼ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ Ð¿ÐµÑ€ÐµÐ´ Ð½Ð°Ñ‡Ð°Ð»Ð¾Ð¼
    logging.info(f"Received /start command from {message.from_user.id}")

    button = InlineKeyboardButton(text="ÐÐ°Ñ‡Ð°Ñ‚ÑŒ Ð¾Ð±ÑƒÑ‡ÐµÐ½Ð¸Ðµ!", callback_data="start_learning")
    keyboard = InlineKeyboardMarkup(inline_keyboard=[[button]])

    await message.answer("Ð”Ð¾Ð±Ñ€Ð¾ Ð¿Ð¾Ð¶Ð°Ð»Ð¾Ð²Ð°Ñ‚ÑŒ! ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ ÐºÐ½Ð¾Ð¿ÐºÑƒ Ð½Ð¸Ð¶Ðµ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð½Ð°Ñ‡Ð°Ñ‚ÑŒ Ð¸Ð·ÑƒÑ‡ÐµÐ½Ð¸Ðµ:", reply_markup=keyboard)

    # ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
    try:
        first_name = message.from_user.first_name
        last_name = message.from_user.last_name

        full_name = f"{first_name} {last_name}" if first_name and last_name else first_name or last_name or ""

        upsert_user(message.from_user.id, message.from_user.username or '', full_name)
        logging.info(f"User data updated for {message.from_user.id}")
    except Exception as e:
        logging.error(f"Error while updating user data: {e}")

########################################################################################################################

async def get_top_users() -> list:
    async with aiosqlite.connect("database.db") as db:
        async with db.execute(
                "SELECT user_id, full_name, learned_words_count FROM users ORDER BY learned_words_count DESC LIMIT 15"
        ) as cursor:
            rows = await cursor.fetchall()
            return rows

# @dp.callback_query(F.data == "top_leaders")
# async def top_users(message: types.Message, callback_query: types.CallbackQuery, state: FSMContext) -> None:
#     top_users = await get_top_users()
#
#     if not top_users:
#         await callback_query.message.answer("Ð¢Ð¾Ð¿-15 Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹ Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÐµÑ‚.")
#         return
#     first_name = message.from_user.first_name
#     last_name = message.from_user.last_name
#     response = "*Top-15 Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹ Ð¿Ð¾ Ð¸Ð·ÑƒÑ‡ÐµÐ½Ð½Ñ‹Ð¼ ÑÐ»Ð¾Ð²Ð°Ð¼:*\n\n"
#     for idx, (user_id, full_name, learned_words_count) in enumerate(top_users, start=1):
#         full_name = f"{first_name} {last_name}" if first_name and last_name else first_name or last_name or "ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ"
#         user_link = f"[{full_name}](tg://user?id={user_id})"  # Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ ÑÑÑ‹Ð»ÐºÑƒ
#         response += f"{idx}. {user_link} - {learned_words_count} ÑÐ»Ð¾Ð²\n"
#
#     response = response.replace(".", "\\.").replace("-", "\\-")
#     (await callback_query.message.answer(response, parse_mode='MarkdownV2')

@dp.callback_query(F.data == "top_leaders")
async def top_users(callback_query: types.CallbackQuery, state: FSMContext) -> None:
    rows = await get_top_users()

    if not rows:
        await callback_query.answer("Ð¢Ð¾Ð¿-15 Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹ Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÐµÑ‚.")
        return

    response = "*Top-15 Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹ Ð¿Ð¾ Ð¸Ð·ÑƒÑ‡ÐµÐ½Ð½Ñ‹Ð¼ ÑÐ»Ð¾Ð²Ð°Ð¼:*\n\n"
    for idx, (user_id, full_name, learned_words_count) in enumerate(rows, start=1):
        user_link = f"[{full_name}](tg://user?id={user_id})"  # Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ ÑÑÑ‹Ð»ÐºÑƒ
        response += f"{idx}. {user_link} - {learned_words_count} ÑÐ»Ð¾Ð²\n"

    response = response.replace(".", "\\.").replace("-", "\\-")

    await callback_query.message.answer(response, parse_mode='MarkdownV2')


########################################################################################################################

async def get_user_data(user_id: int):
    async with aiosqlite.connect("database.db") as db:
        async with db.execute(
                "SELECT full_name, elite_status, learned_words_count FROM users WHERE user_id = ?",
                (user_id,)) as cursor:
            row = await cursor.fetchone()
            if row:
                return row[0], row[1], row[2]
            else:
                return None, None, None, 0  # Ð’ÐµÑ€Ð½Ñ‘Ð¼ 0 Ð´Ð»Ñ Ð¸Ð·ÑƒÑ‡ÐµÐ½Ð½Ñ‹Ñ… ÑÐ»Ð¾Ð², ÐµÑÐ»Ð¸ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½

# Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ ÐºÐ½Ð¾Ð¿ÐºÐ¸ "ÐŸÑ€Ð¾Ñ„Ð¸Ð»ÑŒ"
@dp.message(F.text == "ÐŸÑ€Ð¾Ñ„Ð¸Ð»ÑŒ")
async def check_profile(message: types.Message, state: FSMContext) -> None:
    await state.clear()
    user_id = message.from_user.id
    first_name = message.from_user.first_name
    last_name = message.from_user.last_name
    full_name, elite_status, learned_words_count = await get_user_data(user_id)

    full_name = f"{first_name} {last_name}" if first_name and last_name else first_name or last_name or "ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ"

    elite_status_text = " ðŸ’ŽÐ­Ð»Ð¸Ñ‚Ð½Ñ‹Ð¹" if elite_status == "Yes" else " ðŸ†“Free"  # ÐŸÑ€Ð¸Ð¼ÐµÑ€ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ ÑÑ‚Ð°Ñ‚ÑƒÑÐ°

    button = InlineKeyboardButton(text="Leaders Page", callback_data="top_leaders")
    keyboard = InlineKeyboardMarkup(inline_keyboard=[[button]])

    await message.answer(
        f"Ð˜Ð¼Ñ: [{full_name}](tg://user?id={user_id})\n\nÐ˜Ð·ÑƒÑ‡ÐµÐ½Ð½Ñ‹Ðµ ÑÐ»Ð¾Ð²Ð°: {learned_words_count}\nÐ¡Ñ‚Ð°Ñ‚ÑƒÑ: {elite_status_text}",
        parse_mode='Markdown', reply_markup=keyboard
    )
########################################################################################################################

# Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ð³Ð¾ Ñ‚ÐµÐºÑÑ‚Ð°
@dp.message(F.text)
async def handle_any_text(message: types.Message, state: FSMContext) -> None:
    current_state = await state.get_state()
    if current_state is not None:  # Ð•ÑÐ»Ð¸ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾
        await state.clear()  # Ð¡Ð±Ñ€Ð°ÑÑ‹Ð²Ð°ÐµÐ¼ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ
        await message.answer("Ð¢ÐµÐºÑƒÑ‰ÐµÐµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ Ð¾Ñ‚Ð¼ÐµÐ½ÐµÐ½Ð¾. Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð½Ð¾Ð²Ð¾Ðµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ.")
########################################################################################################################

# Ð—Ð°Ð¿ÑƒÑÐº Ð±Ð¾Ñ‚Ð°
async def main() -> None:
    logging.info("Bot is starting...")
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
